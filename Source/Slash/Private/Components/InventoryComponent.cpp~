// Fill out your copyright notice in the Description page of Project Settings.


#include "Components/InventoryComponent.h"

#include "EnhancedInputComponent.h"
#include "Blueprint/UserWidget.h"
#include "Camera/CameraComponent.h"
#include "Characters/MainCharacter.h"
#include "HUD/Inventory/Inventory.h"
#include "items/Eatable.h"
#include "Kismet/KismetSystemLibrary.h"

UInventoryComponent::UInventoryComponent()
{
	PrimaryComponentTick.bCanEverTick = true;

	MoneyAmount = 0;
	InventoryAction = nullptr;
	// CurrentItem = FSlotData();
}


void UInventoryComponent::BeginPlay()
{
	Super::BeginPlay();
	
	if (AActor* Owner = Cast<AMainCharacter>(GetOwner()))
	{
		if (UEnhancedInputComponent* Input = Cast<UEnhancedInputComponent>(Owner->InputComponent))
		{
			Input->BindAction(InventoryAction, ETriggerEvent::Started, this, &UInventoryComponent::OpenInventory);
			Input->BindAction(GrabAction, ETriggerEvent::Started, this, &UInventoryComponent::GrabItem);
		}	
	}

	if (APlayerController* PC = Cast<APlayerController>(GetOwner()->GetNetOwningPlayer()->PlayerController))
	{
		GrabWidget = CreateWidget<UUserWidget>(PC, GrabWidgetClass);
	}

	// Setting The size of Inventory -------------------------------------------------------------------------------->
	// AllItem.EatableItems.SetNum(MaxEatableSize);
	// AllItem.MeleItems.SetNum(MaxMeleItemSize);
	// AllItem.RangedItems.SetNum(MaxRangedItemSize);
}

void UInventoryComponent::OpenInventory(const FInputActionValue& Value)
{
	UE_LOG(LogTemp, Display, TEXT("Open Inventory"));
	if (APlayerController* PC = Cast<APlayerController>(GetOwner()->GetNetOwningPlayer()->PlayerController))
	{
		if (InventoryMenu)
		{
			PC->SetShowMouseCursor(true);
			FInputModeUIOnly InputMode;
			InputMode.SetWidgetToFocus(InventoryMenu->TakeWidget());
			InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
			PC->SetInputMode(InputMode);
			InventoryMenu->AddToViewport();
		} else
		{
			InventoryMenu = CreateWidget<UInventory>(PC, InventoryClass);
			if (InventoryMenu)
			{
				PC->SetShowMouseCursor(true);
				FInputModeUIOnly InputMode;
				InputMode.SetWidgetToFocus(InventoryMenu->TakeWidget());
				InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
				PC->SetInputMode(InputMode);
				InventoryMenu->AddToViewport();
			}
			
		}
	}
}

void UInventoryComponent::GrabItem(const FInputActionValue& Value)
{
	UE_LOG(LogTemp, Display, TEXT("Grab Item"));

	bool bFoundExistingStack = false;
	switch (CurrentItem.ItemType)
	{
		case EItemType::EIT_Mele :
			{
				UE_LOG(LogTemp, Display, TEXT("Mele Item"));
				if (MeleItemSize != MaxMeleItemSize)
				{
					AddItem(CurrentItem, bFoundExistingStack, AllItem.MeleItems, OtherActor, MeleItemSize, MaxMeleItemSize);
					MeleItemSize++;
				}
				break;
			}
		case EItemType::EIT_Ranged :
			{
				UE_LOG(LogTemp, Display, TEXT("Ranged Item"));
				if (RangedItemSize != MaxRangedItemSize)
				{
					AddItem(CurrentItem, bFoundExistingStack, AllItem.RangedItems, OtherActor, RangedItemSize, MaxRangedItemSize);
					RangedItemSize++;
				}
				break;
			}
		case EItemType::EIT_Eatable :
			{
				UE_LOG(LogTemp, Display, TEXT("Eatable Item"));
				if (EatableSize != MaxEatableSize)
				{
					AddItem(CurrentItem, bFoundExistingStack, AllItem.EatableItems, OtherActor, EatableSize, MaxEatableSize);
					EatableSize++;
				}
				break;
			}
		default:
			{
				UE_LOG(LogTemp, Display, TEXT("Invalid Item Type"));
			}
	}
}

void UInventoryComponent::AddItem(FSlotData Item, bool &bFoundExistingStack, TArray<FSlotData> &Arr, AActor* ItemActor, int32 ItemIndex, int32 ItemSize)
{
	for (FSlotData& ExistingItem : Arr)
	{
		bool bCheckSlotSize = ((ExistingItem.Quantity + CurrentItem.Quantity) < ItemSize);
		if (ExistingItem.ItemID.RowName == CurrentItem.ItemID.RowName && bCheckSlotSize)
		{
			ExistingItem.Quantity += CurrentItem.Quantity;
			bFoundExistingStack = true;
			break;
		}
		Arr.Push(CurrentItem);
	}

	if (!bFoundExistingStack) Arr.Push(CurrentItem);

	OtherActor->Destroy();
}


void UInventoryComponent::TraceToPickUp()
{
	const AMainCharacter* Owner = Cast<AMainCharacter>(GetOwner());
	FVector start = Owner->Camera->GetComponentLocation();
	FVector end = Owner->Camera->GetForwardVector();
	end = (end * 500.f) + start;

	FHitResult HitResult;
	const TArray<AActor*> ActorToIgnore;
	
	const bool hit = UKismetSystemLibrary::SphereTraceSingle(
		GetWorld(),
		start,
		end,
		20.f,
		TraceTypeQuery1,
		false,
		ActorToIgnore,
		EDrawDebugTrace::ForOneFrame,
		HitResult,
		true
		);

	// FSlotData PrevItem = CurrentItem;
	// && PrevItem.ItemID != CurrentItem.ItemID

	if (hit && Cast<AEatable>(HitResult.GetActor()))
	{
		CurrentItem = Cast<AEatable>(HitResult.GetActor())->SlotData;
		OtherActor = Cast<AEatable>(HitResult.GetActor());
		GrabWidget->AddToViewport();
	}
	else  GrabWidget->RemoveFromParent();
}


void UInventoryComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	TraceToPickUp();
}

